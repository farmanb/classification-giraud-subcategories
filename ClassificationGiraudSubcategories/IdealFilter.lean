/-
Copyright (c) 2025 Blake Farman. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Blake Farman
-/
import Mathlib.GroupTheory.Coset.Basic
import Mathlib.RingTheory.Ideal.Basic
import Mathlib.RingTheory.Ideal.Colon
import Mathlib.Topology.Algebra.Group.Defs
import Mathlib.Topology.Algebra.LinearTopology
import Mathlib.Topology.Algebra.Monoid.Defs
import Mathlib.Topology.Algebra.Ring.Basic
import Mathlib.Tactic.Abel
import Mathlib.Tactic.NoncommRing

open scoped Pointwise
--import Mathlib.Topology.Defs.Basic
/-!
# Ideal Filters

An **ideal filter** is a filter in the lattice of ideals of a ring `A`.

## Main definitions

* `IdealFilter A`: the type of an ideal filter on a ring `A`.
* `IsUniform F` : a filter `F` is uniform if whenever `I` is an ideal in the filter, then for all
`a : A`, the colon ideal `(I : a)` is in `F`.
* `IsTorsionElem` : Given a filter `F`, an element, `m`, of an `A`-module, `M`, is `F`-torsion if
there exists an ideal `L` in `F` that annihilates `m`.
* `IsTorsion` : Given a filter `F`, an `A`-module, `M`, is torsion if every element is torsion.
* `GabrielComposition` : Given two filters `F` and `G`, the Gabriel composition of `F` and `G` is
the set of ideals `L` of `A` such that there exists an ideal `K` in `G` with `K/L` `F`-torsion.
This is again a filter.
* `IsGabriel F` : a filter `F` is uniform if

## References

* [Bo Stenström, Rings and Modules of Quotients][stenstrom1971]

## Tags

category theory, ideal, filter, ultrafilter, Gabriel filter
-/
universe u v

structure IdealFilter (A : Type u) [Ring A] where
  (sets : Set (Ideal A))
  (nonempty : sets.Nonempty)
  (upward_closed : ∀ {I J : Ideal A}, I ∈ sets → I ≤ J → J ∈ sets)
  (inter_closed  : ∀ {I J : Ideal A}, I ∈ sets → J ∈ sets → I ⊓ J ∈ sets)

namespace IdealFilter

variable {A : Type u} [Ring A]
--structure IsUniform {A : Type u} [Ring A] (F : IdealFilter A) : Prop where
structure IsUniform (F : IdealFilter A) : Prop where
   (colon_closed : ∀ {I : Ideal A}, I ∈ F.sets →
      ∀ a : A, (I.colon (Ideal.span {a})) ∈ F.sets)

section topology
variable (F : IdealFilter A)

def nhds_basis_of_pt (a : A) : FilterBasis A where
  --sets := a +ᵥ {s | ∃ I ∈ F.sets, s = I.carrier}
  sets := a +ᵥ {s | ∃ I ∈ F.sets, s = (I : Set A)}
  nonempty := by
    obtain ⟨I, h_I⟩ := F.nonempty
    exact ⟨a +ᵥ (I : Set A), ⟨(I : Set A), ⟨I, h_I, rfl⟩, rfl⟩⟩
  inter_sets := by
    rintro s t ⟨s', ⟨I,h_I,rfl⟩, rfl⟩ ⟨t', ⟨J, h_J, rfl⟩, rfl⟩
    exact ⟨a +ᵥ ((I ⊓ J) : Set A),
      ⟨((I ⊓ J) : Set A), ⟨I ⊓ J, F.inter_closed h_I h_J, rfl⟩, rfl⟩,
      by simp⟩

def nhds_of_IdealFilter (a : A) : Filter A := FilterBasis.filter (nhds_basis_of_pt F a)

/-- The topology on `A` induced by an ideal filter `F`.

A subset `s : Set A` is declared open if for every `x ∈ s` there exists an ideal `I ∈ F.sets`
such that the (left) coset `x +ᵥ I` is contained in `s`. Equivalently, the sets `x +ᵥ I` with
`I ∈ F.sets` form a neighborhood basis at each point `x`.

This is the standard way to build a (left) linear topology from a family of ideals, and it is
the starting point for proving that additional hypotheses on `F` (e.g. uniformity) make `A` into
a topological ring. -/
def topology_of_IdealFilter : TopologicalSpace A :=
  TopologicalSpace.mkOfNhds (nhds_of_IdealFilter F)

/-- In the topology on `A` induced by an ideal filter `F`, every translate `x +ᵥ I` of an ideal
`I ∈ F.sets` is an open neighborhood of `x`.

This is the basic “linear” feature of `topology_of_IdealFilter`: neighborhoods are generated by
(translates of) ideals coming from the filter. -/
lemma isOpen_leftAddCoset (x : A) {I : Ideal A} (h_I : I ∈ F.sets) :
      letI : TopologicalSpace A := topology_of_IdealFilter F
      IsOpen (x +ᵥ (I : Set A)) := by
  rintro y ⟨z, h_z : z ∈ I, h_sum : x + z = y⟩
  refine ⟨y +ᵥ (I : Set A), ⟨(I : Set A), ⟨I, h_I, rfl⟩, rfl⟩, ?_⟩
  have : x +ᵥ (I : Set A) = y +ᵥ (I : Set A) := by
    apply (leftAddCoset_eq_iff (I.toAddSubgroup)).mpr
    simp[← h_sum,h_z]
  rw[this]

/-- Algebraic core of continuity of addition for `topology_of_IdealFilter`.

If a set `s` contains the translate `(a + b) +ᵥ I` of an ideal `I`, then the preimage of `s`
under addition contains the rectangle `(a +ᵥ I) ×ˢ (b +ᵥ I)`. In other words, translating by `I`
in each coordinate keeps sums inside `s`. -/
lemma prod_leftAddCoset_subset_preimage_add
    (s : Set A) (a b : A) (I : Ideal A)
    (h_translate : (a + b) +ᵥ (I : Set A) ⊆ s) :
    (a +ᵥ (I : Set A)) ×ˢ (b +ᵥ (I : Set A)) ⊆ (fun p : A × A ↦ p.1 + p.2) ⁻¹' s := by
  rintro ⟨p₁, p₂⟩ ⟨⟨u, h_u, rfl⟩, ⟨v, h_v, rfl⟩⟩
  apply h_translate
  refine ⟨u + v, I.add_mem h_u h_v, ?_⟩
  change a + b + (u + v) = a + u + (b + v)
  abel

/-- The underlying additive group of `A` is a topological group for the topology induced by an
ideal filter `F`.

More precisely, with `TopologicalSpace A` given by `topology_of_IdealFilter F` (whose neighborhoods
of a point `x` are generated by cosets `x +ᵥ I` for ideals `I ∈ F.sets`), both addition
`(fun p : A × A ↦ p.1 + p.2)` and negation `(fun x : A ↦ -x)` are continuous, yielding an
`IsTopologicalAddGroup` instance. -/
def isTopologicalAddGroup :
    letI : TopologicalSpace A := topology_of_IdealFilter F
    IsTopologicalAddGroup A := by
  letI isTopologicalSpace : TopologicalSpace A := topology_of_IdealFilter F
  refine { toContinuousAdd := ?_, toContinuousNeg := ?_ }
  · refine { continuous_add := ?_ }
    refine {
      isOpen_preimage := by
        intro s h_s
        refine isOpen_prod_iff.mpr ?_
        intro a b (h_ab : a + b ∈ s)
        rcases h_s (a + b) h_ab with ⟨t, h_t, h_translate⟩
        rcases h_t with ⟨u,h_u₁,rfl⟩
        rcases h_u₁ with ⟨I, h_I, rfl⟩
        refine ⟨a +ᵥ (I : Set A),
          b +ᵥ (I : Set A),
          isOpen_leftAddCoset F a h_I,
          isOpen_leftAddCoset F b h_I,
          mem_own_leftAddCoset I.toAddSubmonoid a,
          mem_own_leftAddCoset I.toAddSubmonoid b,
          prod_leftAddCoset_subset_preimage_add s a b I h_translate⟩
    }
  · refine { continuous_neg := {
      isOpen_preimage := by
        intro s h_s x (h_nx : -x ∈ s)
        rcases h_s (-x) h_nx with ⟨t,h_t,h_ts⟩
        rcases h_t with ⟨u, h_u, rfl⟩
        rcases h_u with ⟨I, h_I, rfl⟩
        change -x +ᵥ (I : Set A) ⊆ s at h_ts
        refine ⟨x +ᵥ (I : Set A), ⟨I, ⟨I, h_I, rfl⟩,rfl⟩,?_⟩
        intro y ⟨z,h_z,(h_sum : x + z = y)⟩
        change -y ∈ s
        rw[← h_sum, neg_add]
        apply h_ts
        exact ⟨-z, Submodule.neg_mem I h_z, rfl⟩
  } }

def isTopologicalRing (uni_F : IsUniform F) :
    letI : TopologicalSpace A := topology_of_IdealFilter F
    IsTopologicalRing A := by
      letI isTopologicalSpace_A: TopologicalSpace A := topology_of_IdealFilter F
      letI isTopologicalAddGroup_A : IsTopologicalAddGroup A := isTopologicalAddGroup F
      exact{
      continuous_add := continuous_add
      continuous_mul := {
        isOpen_preimage := by
          intro s h_s
          refine isOpen_prod_iff.mpr ?_
          intro a b (h_ab : a*b ∈ s)
          rcases h_s (a*b) h_ab with ⟨t,h_t,h_ts⟩
          rcases h_t with ⟨u,h_u,rfl⟩
          rcases h_u with ⟨I, h_I, rfl⟩
          refine ⟨a +ᵥ ((I.colon (Ideal.span {b})) : Set A),
            b +ᵥ (I : Set A),
            isOpen_leftAddCoset F a (uni_F.colon_closed h_I b),
            isOpen_leftAddCoset F b h_I,
            mem_own_leftAddCoset _ a,
            mem_own_leftAddCoset _ b,
            ?_⟩
          · rintro ⟨p₁,p₂⟩ ⟨h_p₁, h_p₂⟩
            rcases h_p₁ with ⟨x, h_x, rfl⟩
            rcases h_p₂ with ⟨y, h_y, rfl⟩
            apply h_ts
            change (a + x) * (b + y) ∈ (a*b) +ᵥ (I : Set A)
            refine (mem_leftAddCoset_iff (a*b)).mpr ?_
            rw[add_mul, mul_add, ← add_assoc, ← add_assoc, neg_add_cancel, zero_add, mul_add,
               ←add_assoc]
            exact I.add_mem
              (I.add_mem (Ideal.mul_mem_left I a h_y)
                (Submodule.mem_colon.mp h_x b (Ideal.mem_span_singleton_self b)))
              (Ideal.mul_mem_left I x h_y)
      }
      continuous_neg := continuous_neg
      }
end topology


/-- We say that an element `m : M` is `F`-torsion if it is annihilated by some ideal belonging to
the filter `F`.  That is, there exists `L ∈ F.sets` such that every `a ∈ L` satisfies
`a • m = 0`. -/
def IsTorsionElem (F : IdealFilter A)
      {M : Type v} [AddCommMonoid M] [Module A M] (m : M) : Prop :=
   ∃ L ∈ F.sets, ∀ a ∈ L, a • m = 0

/-- We say that an `A`-module `M` is `F`-torsion if every element of `M` is `F`-torsion in the
sense of `IsTorsionElem`. -/
def IsTorsion (F : IdealFilter A)
      (M : Type v) [AddCommMonoid M] [Module A M] : Prop :=
   ∀ m : M, IsTorsionElem F m

/-- We say that the quotient `K/L` is `F`-torsion if every element `k ∈ K` is annihilated
(modulo `L`) by some ideal in `F`.  Equivalently, for each `k ∈ K` there exists `I ∈ F.sets`
such that `I ≤ L.colon (Ideal.span {k})`. That is to say, every `a ∈ I` satisfies `a * k ∈ L`.
This formulation avoids forming the quotient module explicitly. -/
def IsTorsionQuot (F : IdealFilter A) (L K : Ideal A) : Prop :=
   ∀ k ∈ K, ∃ I ∈ F.sets, I ≤ L.colon (Ideal.span {k})

lemma colon_inf_eq_for_mem
     (L K : Ideal A) {k : A} (hk : k ∈ K) :
    (L ⊓ K).colon (Ideal.span ({k} : Set A)) =
      L.colon (Ideal.span ({k} : Set A)) := by
  -- ext `a : A` and unpack `Submodule.mem_colon`
  ext a
  constructor <;> intro ha
  · -- `a ∈ (L ⊓ K).colon(span{k})` ⇒ `a ∈ L.colon(span{k})`
    -- use Submodule.mem_colon to rewrite membership
    rcases (Submodule.mem_colon).1 ha with h
    -- need: ∀ p ∈ span{k}, a • p ∈ L
    apply (Submodule.mem_colon).2
    intro p hp
    -- p ∈ span{k} ⇒ p = r * k
    obtain ⟨r, rfl⟩ := Ideal.mem_span_singleton'.1 hp
    -- from h we know: a • (r * k) ∈ L ⊓ K
    specialize h (r * k) ?_
    · exact hp
    · rcases h with ⟨hL, hK⟩
      exact hL
  · -- same in the other direction, using that k ∈ K gives automatic K-membership
    rcases (Submodule.mem_colon).1 ha with h
    apply (Submodule.mem_colon).2
    intro p hp
    obtain ⟨r, rfl⟩ := Ideal.mem_span_singleton'.1 hp
    -- a • (r * k) ∈ L by h
    have hL : a • (r * k) ∈ L := by
      apply h
      exact hp
    -- and also a • (r * k) ∈ K because k ∈ K and K is an ideal
    have hK : a • (r * k) ∈ K := by
      -- use closure of K under multiplication by scalars and membership of k
      -- this is just Ideal.mul_mem_left followed by ring simp
      simpa [mul_assoc, smul_mul_assoc] using
        Ideal.mul_mem_left K a (Ideal.mul_mem_left K r hk)
    exact ⟨hL, hK⟩

@[simp]
lemma IsTorsionQuot_inter_left_iff
     (F : IdealFilter A)
    (L K : Ideal A) :
    IsTorsionQuot F L K ↔ IsTorsionQuot F (L ⊓ K) K := by
  unfold IsTorsionQuot
  constructor
  · intro h k hk
    -- use the witness from `h`, then rewrite the colon using the lemma
    rcases h k hk with ⟨I, hI, hI_le⟩
    refine ⟨I, hI, ?_⟩
    -- `I ≤ L.colon(span{k})` and those two colon ideals are equal
    · have hcol :=
        colon_inf_eq_for_mem (L := L) (K := K) (k := k) hk
      simpa [hcol] using hI_le
  · intro h k hk
    rcases h k hk with ⟨I, hI, hI_le⟩
    refine ⟨I, hI, ?_⟩ -- now use equality in the opposite direction
    · have hcol := colon_inf_eq_for_mem (L := L) (K := K) (k := k) hk
      simpa [hcol] using hI_le

@[simp] lemma IsTorsion_def (F : IdealFilter A)
      (M : Type v) [AddCommMonoid M] [Module A M] : IsTorsion F M ↔ ∀ m : M, IsTorsionElem F m :=
  Iff.rfl

@[simp] lemma IsTorsionQuot_def (F : IdealFilter A) (L K : Ideal A) :
      IsTorsionQuot F L K ↔ ∀ k ∈ (K : Set A), ∃ I ∈ F.sets, I ≤ L.colon (Ideal.span {k}) :=
  Iff.rfl

/-- If `x ∈ I`, then the colon ideal `(x : I)` is the whole ring. -/
lemma colon_span_singleton_eq_top_of_mem {I : Ideal A} {x : A} (h_x : x ∈ I) :
    I.colon (Ideal.span {x}) = ⊤ := by
  apply (Ideal.eq_top_iff_one (I.colon (Ideal.span {x}))).mpr
  apply Submodule.mem_colon.mpr
  intro p h_p
  obtain ⟨a,rfl⟩ := Ideal.mem_span_singleton'.mp h_p
  simp only [one_smul,Ideal.mul_mem_left,h_x]

/-- For any filter `F` and ideal `J`, the quotient `J/J` is `F`-torsion in the sense of
`IsTorsionQuot`. -/
lemma IsTorsionQuot_self (F : IdealFilter A) (I : Ideal A) :
    IsTorsionQuot F I I := by
  intro x h_x
  obtain ⟨J, h_J⟩ := F.nonempty
  exact ⟨J, h_J, by simp[colon_span_singleton_eq_top_of_mem h_x]⟩

lemma IsTorsionQuot_mono_left (F : IdealFilter A)
    {I J K : Ideal A} (I_leq_J : I ≤ J) : IsTorsionQuot F I K → IsTorsionQuot F J K := by
  intro I_tors x h_x
  obtain ⟨L, ⟨L_in_F, h_L⟩⟩ := I_tors x h_x
  exact ⟨L, L_in_F, fun y h_y ⦃a⦄ a_1 ↦ I_leq_J (h_L h_y a_1)⟩

def GabrielComposition (F G : IdealFilter A) : IdealFilter A where
  sets := {L : Ideal A | ∃ K ∈ G.sets, F.IsTorsionQuot L K}
  nonempty := by
    obtain ⟨J,h_J⟩ := G.nonempty
    exact ⟨J, J, h_J, IsTorsionQuot_self F J⟩
  upward_closed := by
    rintro I J ⟨K, h_KG, h_K⟩ h_IJ
    exact ⟨K, h_KG, IsTorsionQuot_mono_left F h_IJ h_K⟩
  inter_closed := by
    rintro I J ⟨K,h_KG,h_K⟩ ⟨L,h_LG,h_L⟩
    refine ⟨K ⊓ L, G.inter_closed h_KG h_LG, ?_⟩
    · rintro x ⟨x_K, x_L⟩
      obtain ⟨K₁, K₁_F, h_K₁⟩ := h_K x x_K
      obtain ⟨K₂, K₂_F, h_K₂⟩ := h_L x x_L
      refine ⟨K₁ ⊓ K₂, F.inter_closed K₁_F K₂_F, ?_⟩
      · rintro y ⟨y_K₁, y_K₂⟩
        have h₁ := Submodule.mem_colon.mp (h_K₁ y_K₁)
        have h₂ := Submodule.mem_colon.mp (h_K₂ y_K₂)
        exact Submodule.mem_colon.mpr (fun p h_p => ⟨h₁ p h_p, h₂ p h_p⟩)

-- Declare notation for Gabriel composition
infixl:70 " • " => GabrielComposition

def IsGabrielFilter (F : IdealFilter A) : Prop :=
  F.IsUniform ∧ F • F = F

end IdealFilter
