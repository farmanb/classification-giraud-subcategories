import ClassificationGiraudSubcategories.Basic
import Mathlib.Topology.Algebra.FilterBasis

open scoped Pointwise
open scoped Topology

namespace IdealFilter

variable {A : Type u} [Ring A] (F : IdealFilter A)

def addGroupFilterBasis : AddGroupFilterBasis A where
  sets := {(I : Set A) | I ‚àà F}
  nonempty := by
    obtain ‚ü®I, h_I‚ü© := F.nonempty
    exact ‚ü®I, ‚ü®I, h_I, rfl‚ü©‚ü©
  inter_sets := by
    rintro s t ‚ü®I, h_I, rfl‚ü© ‚ü®J, h_J, rfl‚ü©
    refine ‚ü®I ‚äì J, ‚ü®I ‚äì J, Order.PFilter.inf_mem h_I h_J, rfl‚ü©, ?_‚ü©
    intro x h
    exact h
  zero' := by
    rintro s ‚ü®I, h_I, rfl‚ü©
    exact zero_mem I
  add' := by
    rintro s ‚ü®I, h_I, rfl‚ü©
    refine ‚ü®I, ‚ü®I, h_I, rfl‚ü©, Set.add_subset_iff.mpr ?_‚ü©
    exact fun x a y a_1 ‚Ü¶ add_mem a a_1
  neg' := by
    rintro s ‚ü®I, h_I, rfl‚ü©
    exact ‚ü®I, ‚ü®I, h_I, rfl‚ü©, by simp‚ü©
  conj' := by
    rintro x‚ÇÄ s ‚ü®I, h_I, rfl‚ü©
    exact ‚ü®I, ‚ü®I, h_I, rfl‚ü©, by simp‚ü©

def ringFilterBasis (uni_F : F.IsUniform) : RingFilterBasis A where
  sets := F.addGroupFilterBasis.sets
  nonempty := F.addGroupFilterBasis.nonempty
  inter_sets := F.addGroupFilterBasis.inter_sets
  zero' := F.addGroupFilterBasis.zero'
  add' := F.addGroupFilterBasis.add'
  neg' := F.addGroupFilterBasis.neg'
  conj' := F.addGroupFilterBasis.conj'
  mul' := by
    rintro s ‚ü®I, h_I, rfl‚ü©
    exact ‚ü®I, ‚ü®I, h_I, rfl‚ü©, Set.mul_subset_iff.mpr fun _ h‚ÇÅ _ h‚ÇÇ => mul_mem h‚ÇÅ h‚ÇÇ‚ü©
  mul_left' := by
    rintro x‚ÇÄ s ‚ü®I, h_I, rfl‚ü©
    refine ‚ü®I, ‚ü®I, h_I, rfl‚ü©, ?_‚ü©
    intro x h_x
    exact Ideal.mul_mem_left I x‚ÇÄ h_x
  mul_right' := by
    rintro x‚ÇÄ s ‚ü®I, h_I, rfl‚ü©
    refine ‚ü®I.colon (Ideal.span {x‚ÇÄ}), ?_, ?_‚ü©
    ¬∑ exact ‚ü®I.colon (Ideal.span {x‚ÇÄ}), uni_F.colon_mem h_I x‚ÇÄ, rfl‚ü©
    ¬∑ intro x h_x
      exact Submodule.mem_colon.mp h_x x‚ÇÄ (Ideal.mem_span_singleton_self x‚ÇÄ)

def addGroupTopology : TopologicalSpace A := (addGroupFilterBasis F).topology

theorem isTopologicalAddGroup :
    letI : TopologicalSpace A := F.addGroupTopology
    IsTopologicalAddGroup A :=
  F.addGroupFilterBasis.isTopologicalAddGroup

def ringTopology (uni_F : F.IsUniform) : TopologicalSpace A :=
  (ringFilterBasis F uni_F).topology

theorem isTopologicalRing (uni_F : F.IsUniform) :
    letI : TopologicalSpace A := F.ringTopology uni_F
    IsTopologicalRing A :=
  (F.ringFilterBasis uni_F).isTopologicalRing

/-- In the topology on `A` induced by an ideal filter `F`, every translate `x +·µ• I` of an ideal
`I ‚àà F` is an open neighborhood of `x`.

This is the basic ‚Äúlinear‚Äù feature of `addGroupTopology`: neighborhoods are generated by
(translates of) ideals coming from the filter. -/
lemma isOpen_leftAddCoset (x : A) {I : Ideal A} (h_I : I ‚àà F) :
    letI : TopologicalSpace A := F.addGroupTopology
    IsOpen (x +·µ• (I : Set A)) := by
  letI : TopologicalSpace A := F.addGroupTopology
  refine (isOpen_iff_mem_nhds).mpr ?_
  rintro y ‚ü®z, h_z, rfl‚ü©
  have : x +·µ• (I : Set A) = (x + z) +·µ• (I : Set A) := by
    have : z +·µ• (I : Set A) = (I : Set A) :=
      leftAddCoset_mem_leftAddCoset I.toAddSubgroup h_z
    rw [‚Üê leftAddCoset_assoc, this]
  rw [this]
  refine ((F.addGroupFilterBasis).nhds_hasBasis (x + z)).mem_iff.2 ?_
  refine ‚ü®(I : Set A), ?_, ?_‚ü©
  ¬∑ exact ‚ü®I, h_I, rfl‚ü©
  ¬∑ intro y hy; exact hy

lemma mem_nhds_iff (a : A) (s : Set A) :
    letI : TopologicalSpace A := F.addGroupTopology
    s ‚àà ùìù a ‚Üî ‚àÉ I ‚àà F, a +·µ• (I : Set A) ‚äÜ s := by
  constructor
  ¬∑ intro h_s
    rcases ((F.addGroupFilterBasis).nhds_hasBasis a).mem_iff.1 h_s with ‚ü®t, ht, hts‚ü©
    rcases ht with ‚ü®I, hI, rfl‚ü©
    exact ‚ü®I, hI, hts‚ü©
  ¬∑ rintro ‚ü®I, hI, hIs‚ü©
    refine ((F.addGroupFilterBasis).nhds_hasBasis a).mem_iff.2 ?_
    exact ‚ü®(I : Set A), ‚ü®I, hI, rfl‚ü©, hIs‚ü©

/-- A set is open in `F.addGroupTopology` iff it contains a basic coset neighborhood around
each of its points. -/
lemma isOpen_iff_exists_leftAddCoset_subset (s : Set A) :
    letI : TopologicalSpace A := F.addGroupTopology
    IsOpen s ‚Üî ‚àÄ a ‚àà s, ‚àÉ I ‚àà F, a +·µ• (I : Set A) ‚äÜ s := by
  letI : TopologicalSpace A := F.addGroupTopology
  constructor
  ¬∑ intro h_s a h_a
    rw [‚Üê F.mem_nhds_iff a s]
    exact IsOpen.mem_nhds h_s h_a
  ¬∑ intro h
    refine (isOpen_iff_mem_nhds).2 ?_
    intro a h_a
    exact (F.mem_nhds_iff a s).2 (h a h_a)

end IdealFilter
